#!/bin/bash
# <meta:header>
#   <meta:licence>
#     Copyright (C) 2013 by Wizzard Solutions Ltd, ischnura@metagrid.co.uk
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#   </meta:licence>
# </meta:header>
#
#
binpath=$(dirname $(readlink -f ${0}))
srcpath=$(dirname ${binpath:?})
toppath=$(dirname ${srcpath:?})
datpath=${srcpath:?}/dat


#
# Load our local configuration.
cfgfile=${srcpath:?}/config
if [ -e "${cfgfile:?}" ]
then
    source "${cfgfile:?}"
else
    echo "ERROR : unable to find config [${cfgfile}]"
    #exit -1
fi

#
# Set the default settings.
: ${tempdir:='/tmp'}
: ${basepool:='base'}
: ${livepool:='live'}
: ${connection:='qemu:///system'}

#
# Check the configuration data.
echo ""
echo "INFO : Base pool  [${basepool:?}]"
echo "INFO : Live pool  [${livepool:?}]"
echo "INFO : Connection [${connection:?}]"

echo ""
echo "INFO : Data path  [${datpath:?}]"

echo ""
echo "INFO : Machines   [${machines:?}]"
echo "INFO : Template   [${template:?}]"

if [ ! -f "${machines}" ]
then
    echo "ERROR : unable to find machines [${machines}]"
    #exit -1
fi

if [ ! -f "${template}" ]
then
    echo "ERROR : unable to find template [${template}]"
    #exit -1
fi

#
# Load our input utils.
if [ ! -f "${binpath}/utils" ]
then
    echo "ERROR : unable to load utils [${binpath}/utils]"
    #exit -1
else
    source "${binpath}/utils"
fi

#
# Select the machine name.
echo ""
#echo "Available machine names"
thisname=$(hostname -s)
namelist=( $(cat "${machines:?}" | awk '{if ($1 == "'${thisname:?}'") {print $2}}') )
for ((index = 0 ; index < ${#namelist[@]} ; index++))
do
    echo "[$[index + 1]] ${namelist[$index]}"
done

nodename=''
while [ "${nodename}" == '' ]
do
    read -p "Select machine name (1) " response
    if [ "${response}" == '' ]
    then
        nodename=${namelist[0]}
    else
        words=(${response})
        (( index = ${words[0]}  ))
        (( limit = ${#namelist[@]} ))
        if (( (index > 0) && (index <= limit) ))
        then
            nodename=${namelist[$[index-1]]}
        fi
    fi
done

#
# Select the base volume.
tempdat=$(mktemp)
virsh --connect "${connection:?}" vol-list --pool "${basepool}" > "${tempdat}"
readarray -t -s 2 lines < "${tempdat}"
basepaths=()
basenames=()
for ((index = 0 ; index < ${#lines[@]} ; index++))
do
    line=${lines[$[index]]}
    if [ -n "${line}" ]
    then
        words=(${line})
        basenames[$index]=${words[0]}
        basepaths[$index]=${words[1]}
    fi
done

echo ""
#echo "Available base images"
for ((index = 0 ; index < ${#basenames[@]} ; index++))
do
    echo "[$[index + 1]] ${basenames[$index]}"
done

basepath=''
basename=''
while [ "${basepath}" == '' ]
do
    read -p "Select base image (1) " response
    if [ "${response}" == '' ]
    then
        basepath=${basepaths[0]}
        basename=${basenames[0]}
    else
        words=(${response})
        (( index = ${words[0]} ))
        (( limit = ${#basenames[@]} ))
        if (( (index > 0) && (index <= limit) ))
        then
            basepath=${basepaths[$[index-1]]}
            basename=${basenames[$[index-1]]}
        fi
    fi
done

volsize=$(virsh  --connect "${connection:?}" vol-info --pool "${basepool:?}" "${basename:?}" | sed -n 's/Capacity: *\([0-9]*\)\.\([0-9]*\) \([^ ]*\)/\1\3/p')
volname=${nodename:?}.qcow

echo ""
echo "INFO : Node name [${nodename:?}]"
echo "INFO : Base name [${basename:?}]"
echo "INFO : Base path [${basepath:?}]"
echo "INFO : Disc name [${volname:?}]"
echo "INFO : Disc size [${volsize:?}]"
echo ""

thisname=$(hostname -s)
thisline=($(cat "${machines:?}" | awk '{if (($1 == "'${thisname:?}'") && ($2 == "'${nodename:?}'")) {print}}'))

nodemac=${thisline[2]}
nodeip4=${thisline[3]}
nodeip6=${thisline[4]}

echo "INFO : MAC  [${nodemac}]"
echo "INFO : IPv4 [${nodeip4}]"
echo "INFO : IPv6 [${nodeip6}]"
echo ""

confirm "Create virtual machine"
if [ $? -ne 0 ]
then
    echo "EXIT : Cancelled"
    exit 0
fi

#
# Check for existing VM.
domuuid="$(virsh --connect "${connection:?}" domuuid ${nodename:?} 2>/dev/null)"
if [ -n "${domuuid}" ]
then
    echo ""
    echo "Found existing virtual machine [${nodename:?}]"
    confirm "Delete existing virtual machine"
    if [ $? -eq 0 ]
    then

        #
        # Check for active VM and kill it. 
        nodestate=$(virsh --connect "${connection:?}" domstate "${domuuid:?}")
        case $nodestate in
            paused|running)
                echo "Stopping virtual machine [${nodename:?}]"
                virsh --connect "${connection:?}" destroy "${domuuid:?}"
                ;;        

            *)
                ;;
        esac

        confirm "Delete associated storage"
        if [ $? -eq 0 ]
        then
            echo "Deleting virtual machine [${nodename:?}]"
            virsh --connect "${connection:?}" undefine "${domuuid:?}" --remove-all-storage
        else
            echo "Deleting virtual machine [${nodename:?}]"
            virsh --connect "${connection:?}" undefine "${domuuid:?}"
        fi
    else
        echo "EXIT : Found existing virtual machine [${nodename:?}]"
        exit 0
    fi
fi

#
# Check for existing volume.
voluuid="$(virsh --connect "${connection:?}" vol-key "${volname:?}" --pool "${livepool:?}" 2>/dev/null)"
if [ -n "${voluuid}" ]
then
    echo ""
    echo "Found existing storage voume [${volname:?}]"
    confirm "Delete storage voume"
    if [ $? -eq 0 ]
    then
        echo "Deleting storage volume [${volname:?}]"
        virsh --connect "${connection:?}" vol-delete "${volname:?}" --pool "${livepool:?}"
    else
        echo "EXIT : Found existing storage volume [${volname:?}]"
        exit 0
    fi
fi

#
# Create a new volume, backed by the base image.
echo ""
echo "Creating new volume [${volname:?}]"
virsh --connect "${connection:?}" vol-create-as \
    "${livepool:?}" \
    "${volname:?}" \
    "${volsize:?}" \
    --allocation 0 \
    --format 'qcow2' \
    --backing-vol "${basepath:?}" \
    --backing-vol-format 'qcow2'

virsh --connect "${connection:?}" vol-info --pool "${livepool:?}" "${volname:?}"

#
# Create a new virtual machine.
volpath=$(virsh --connect "${connection:?}" vol-path --pool "${livepool:?}" "${volname:?}")
tempxml=$(mktemp)
sed '
    s|<name>.*</name>|<name>'"${nodename:?}"'</name>|
    s|<source file='\''.*'\''/>|<source file='\'''"${volpath}"''\''/>|
    s|<mac address='\''.*'\''/>|<mac address='\'''"${nodemac:?}"''\''/>|
    ' "${template}" > "${tempxml}"


# Create and start a new instance
echo "Creating new virtual machine [${nodename:?}]"
virsh --connect "${connection:?}" define "${tempxml}"
virsh --connect "${connection:?}" start  "${nodename:?}"

#
# Tidy up ..
rm "${tempxml}"


